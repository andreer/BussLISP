(define last (lambda (lst) 
               (cond ((null (cdr lst)) (car lst))
                     ((quote t) (last (cdr lst))))))
(last (quote (a b c)))
(define l (quote (((hotdogs))(and)(pickle)relish) ))
;awefuiahiweufhaiuwef)))))
(car (car l))
;(define * (lambda (a b)
;  (cond ((eq b 0) 0)
;        ((quote t) (+ a (* a (- b 1)))))))
(* 12 20)
(define add1 (lambda (a) (+ a 1)))
(add1 10)
(- 10 2)
(< 10 2)
(< 10 10)
(> 10 10)
(< 10 11)
(< 3 3)
(define remainder (lambda (a b)
    (cond ((< a b) a)
  ((quote t) (remainder (- a b) b)))))
(remainder 13 3)
(define ultimo (lambda (r t) (+ 1 t)))
(ultimo 13 17)
(define square (lambda (x) (* x x)))
(square 4)
(square (+ 2 5))
(define sum-of-squares (lambda (x y)
  (+ (square x) (square y))))
(sum-of-squares 3 4)
(define f (lambda (a)
  (sum-of-squares (+ a 1) (* a 2))))
(f 5)
(define factorial (lambda (n)
    (cond ((eq n 1) 1)
          ((quote t) (* n (factorial (- n 1)))))))
(factorial 3)
(define gcd (lambda (a b)
	      (cond ((eq b 0) a)
		    ((quote t) (gcd b (remainder a b))))))
(gcd 48 180)
(define map (lambda (f lst)
              (cond ((null lst) lst)
                    ((quote t) (cons (f (car lst))
                                     (map f (cdr lst)))))))
(define numbers (cons 1 (cons 2 (cons 3 nil))))(map square numbers)
(+ (* 3 5) (- 10 6))
(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))
(define abs (lambda (x)
              (cond ((< x 0) (- 0 x))
                    ((quote t) x))))
(abs -3)

(cons (quote a) (quote b))
(define A (lambda (x y)
            (cond ((eq y 0) 0)
                  ((eq x 0) (* 2 y))
                  ((eq y 1) 2)
                  ((quote t) (A (- x 1)
                                (A x (- y 1)))))))
(A 3 3)
(define not (lambda (a)
	      (cond (a nil)
		    ((quote t) (quote t)))))
(not nil)
(not (quote t))
(define or (lambda (a b) (cond ((not (null a)) a) ((not (null b)) b) ((quote t) nil))))
(or nil nil)
(or (quote x) (quote y))
(or nil (quote y))
(or (quote x) nil)

(define else (quote t))

(define fib (lambda (n)
  (cond ((eq n 0) 0)
        ((eq n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2)))))))

(fib 1)
(fib 2)
(fib 3)
(fib 4)
(fib 5)
(fib 6)
(fib 7)
(fib 8)
(fib 9)
(fib 10)

(define fibiter (lambda (a b count)
  (cond ((eq count 0) b)
        (else (fibiter (+ a b) a (- count 1))))))

(define fibi (lambda (n)(fibiter 1 0 n)))

(fib 28)
(fibi 28)

(define first-denomination (lambda (kinds-of-coins)
  (cond ((eq kinds-of-coins 1) 1)
        ((eq kinds-of-coins 2) 5)
        ((eq kinds-of-coins 3) 10)
        ((eq kinds-of-coins 4) 25)
        ((eq kinds-of-coins 5) 50))))
(define cc (lambda (amount kinds-of-coins)
  (cond ((eq amount 0) 1)
        ((or (< amount 0) (eq kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins))))))
(define count-change (lambda (amount)
  (cc amount 5)))
(count-change 100)
(count-change 150)
(count-change 200)

(define cube (lambda (x) (* x (* x x))))

(define p (lambda (x) (- (* 3 x) (* 4 (cube x)))))

(p 10)

(+ 0.1 0.1)
(/ 3 2)

(define sine (lambda (angle)
   (cond ((not (> (abs angle) 0.01)) angle)
       (else (p (sine (/ angle 3.0)))))))

(sine 0)

(sine 0.2)

(sine 3.141593)

(sine 90)
